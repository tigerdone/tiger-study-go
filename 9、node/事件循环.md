


# 6个阶段
## 定时器
定时器指定阈值之后提供的回调可以执行，而不是人希望它被执行的确切时间，定时器回调将在指定时间过去后尽早地运行；然而，操作系统调度或者其他回调的运行可能会延迟他们

## 待处理回调
此阶段执行某些操作系统的回调，例如TCP错误类型。例如，如果TCP套接字在尝试连接时收到**ECONNREFUSED**，则某些*nix系统需要等待以报告错误。这将排队等待在等处理回调阶段执行。

## 空闲
仅供内部使用
## 轮询



## 检查
## 关闭回调

# Node.js 中的Event Loop
与在浏览器中一样，在nodejs中JS最开始在主线程上执行，执行同步任务，发出异步请求，规划定时器生效时间，执行Process.nextTick等，这时时间循环还没开始

在上述过程中，如果没有异步操作，代码在执行完成后便直接退出，如果有，libuv会把不同的异步任务分配给不同的线程，形成事件循环。在同步代码执行后，nodejs便会进入事件循环，依次执行不同队列中的任务。libuv会以异步的方式将任务的执行结果返回给V8引擎，V8引擎再返回给用户

Nodejs事件循环中的消息队列共有8个，若引用之前宏队列、微队列的说法，具体可划分为：
宏队列：
- timer
- pending callback
- idle prepare
- poll
- check
- close callbacks

微队列
- nextTick
- Promise

## 宏队列比较重要的3个
### timer
timer，也就是计时器队列，负责处理setTimeout，和setInterval，定义的回调函数

值得注意的是，不管在浏览器还是在nodejs中，所以的定时器回调函数都不能保证到达时间后立即执行。一是应为从计算机硬件和底层操作系统来看，计时器的实现本身就是不精准的，二是因为poll阶段对timer阶段的深刻影响。因为在没有满足poll阶段的结束条件前，就无法进入下一次事件循环的timer阶段，即使timer队列中已经有计时器到期的回调函数了

### poll
poll称为轮询队列，该阶段会处理除timer和check队列外的绝大多数I/O回调任务，如文件读取、监听用户请求等

这里处理用户请求

事件循环到达该阶段时，它的运行方式为：
- 如果poll队列中有回调任务，则依次执行回调直到清空队列
- 如果poll队列中没有回调任务
-- 若其他丢列中后续可能会出现回调任务，则一直等待，等其他队列中后续的回调任务来临时，结束该阶段，开启下一次事件循环
-- 若等待时间超过预设的时间限制，也会自动进入下一次事件循环
-- 若其他队列中后续不可能出现回调任务，则立即结束该阶段，并在本轮事件循环完成后，退出node程序

poll阶段的超时时间在进入poll阶段之前计算

### check
check称为检查队列，负责处理setImmediate定义的回调函数

setTimeout和setImmediate的不同之处在于， 每次执行到timers队列时，定时器观察者内部会去检查代码中的定时器是否超过定时时间，而setImmediate则是直接将回调任务加入到check队列中。
所以总的来说，setImmediate的执行效率要远高于setTimeout，于是也就出现了下面的无法预测输出结果的情况
```js
    setTimeout(() => {
        console.log('setTimeout');
    }, 0)
    
    setImmediate(() => {
        console.log('setImmediate');
    })
    
    // 上述代码是无法预测先输出那个的
    // 因为即使 setTimeout(xxx, 0)，在计算机运算慢的情况下也不能立刻加入 timers 队列

```
## 微任务队列
对于微任务队列的nextTick和Promise，严格意义上讲也不属于事件循环，在事件循环中，每次打算进入下个阶段之前，必须要先一次反复清空nextTick和promise队列，直到两个队列完全没有即将到来的任务的时候再进入下个阶段。

我们可以通过process.nextTick()将回调函数加入nextTick队列，和通过Promise.resolve().then()，将回调函数加入Promise队列，且nextTick队列的优先级要高于Promise队列，所以process.nextTick是nodejs中执行最快的异步操作




