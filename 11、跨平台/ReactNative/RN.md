
## UI主线程
应用的主线程，单线程。主要负责原生渲染和调用原生能力，用于处理原生控件的绘制。JavaScript线程将UI更新指令发送到原生模块，原生模块再将这些指令传递给UI线程进行实际的渲染。与JavaScript线程是分离的，因此即使JavaScript线程被阻塞，UI线程仍然可以继续处理动画和其他视觉效果

# Js线程：
应用执行的核心线程，单线程。主要解释执行JS代码。在大多数情况下，react native使用的js引擎是JSC（JavaScriptCore）；在使用chrome调试时，所有的js代码都运行在chrome中，并且通过websocket与原生代码通信。此时的运行环境是v8。负责执行所有的JavaScript代码。所有的React组件生命周期方法、事件处理函数、状态更新等都在这个线程上运行，如果某个任务耗时较长，会阻塞整个线程，导致应用卡顿

# Shadow线程
主要用于构建JS与原生控件的布局镜像数据。渲染界面的重要步骤就是布局，布局需要知道每个组件应该渲染到什么位置，这个过程通过yoga实现的。这个一个基于flexbox的跨平台布局引擎。shadow thread会维护一个shadow tree来计算我们的各个组件在native页面的实际布局，然后通过bridge通知native thread渲染UI。Yoga引擎可以在原生线程上运行，而不是在JavaScript线程上运行，从而减轻JavaScript线程的负担

# Native Modules线程
多线程，提供原生能力，处理原上模块的调用。iOS端动过GCD实现，Android端通过AsyncTask实现

ReactNative的运行机制通过JavaScript引擎、Bridge、Native Modules、UIManager和Shadow Tree等组件的协同工作，实现了高效的跨平台应用开发。在应用启动时，ReactNative会初始化一个ReactInstanceManager，该管理器负责创建和管理React应用的实例，加载JavaScript代码并初始化Bridge。ReactInstanceManger会通过JavaScriptExecutor加载JavaScript代码，例如从本地文件系统或网络加载，然后创建一个CatalysInstanceTmpl，负责JavaScript代码的加载和执行，以及Bridge的初始化。CatalysInstanceImpl会创建一个NativeToJsBridge，用于处理JavaScript和原生代码之间的通信，并通过ReactPackage注册所有需要的Native Modules和Views。

Native Modules是用原生语言编写的模块，提供了JavaScript代码可以调用的API，每个Native Module都是一个ReactContextBaseJavaModule的子类。开发者需要创建一个ReactPackage，并在其中注册所需的Native Modules和Views，ReactInstanceManager会调用createNativeModules方法，获取所有注册的NativeModules，并将这些模块注入到JavaScript环境中，JavaScript代码看一个通过全局对象NativeModules访问这些模块。

UIManager是一个特殊的Native Modules，负责处理UI相关的操作，如创建、更新和删除视图。JavaScript代码通过UIManager.createView方法创建一个新的视图，通过UIManager.updateView方法更新视图的属性，通过UIManager.measure方法获取视图的尺寸和位置。UIManager在JavaScript环境中使用的代理对象，通过Bridge调用UIManagerModules的方法


