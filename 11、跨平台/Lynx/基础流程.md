Lynx是双线程架构
分为JS线程和UI线程，UI线程集成了lepus引擎（quickjs的封装，用于解释执行js，同时生成c++结构的虚拟dom树），本质上是一个嵌入了js引擎的c++渲染器，渲染双端页面

1、业务代码预处理，编译打包，静态分析，编译出双线程代码
  将所有业务逻辑代码打包成app-server.js，交由JS线程执行
  将渲染函数(jsx)，手动标记的lepus函数提取出来打包成lepus.js，交由UI线程执行
  渲染函数内的没有标记为lepus的函数，会使用变量替换，运行时由JS线程同步过来

2、打包成一个文件，encode压缩
3、版本控制
  上传到版本控制平台
  客户端启动，向版本控制平台发出请求，检查是否有新版本更新，拉取
  客户端内置，提前拉取
5、decode解构
6、双线程同时启动
  UI线程使用首屏数据（容器准备好的数据，或者写死在代码内的数据）运行编译后的render函数，生成虚拟dom tree，再通过Radon diff算法生成Element Tree，最后由客户端生成平台的UI Tree
  JS线程运行业务逻辑代码，setState时，会把状态同步给UI线程用于渲染
  执行render函数后，如果有无法在lepus线程执行的函数，会在JS线程执行完毕，通过数据回设（数据同步方式）同步给UI线程，进行渲染，实际开发过程中，要避免频繁数据回设


# Lynx跨平台框架
跨平台的框架是双线程架构，分别为UI线程，JS线程

UI线程用于渲染，有一个类似RN新架构的JSI的适配层，
js的解释执行用的是quickjs的封装的lepus引擎，可以在c++环境解释执行js代码，解释js代码执行c++接口，从而执行render函数，生成虚拟树，然后用自研的布局引擎将虚拟树生成对应的客户端组件，叫elementAPI

js线程iOS用的javascriptCore，安卓用的是v8，执行业务逻辑，通过JSB层将JSON序列化同步数据给UI线程用于渲染

## 为什么会使用到两个js引擎？
做极致的性能优化

### RN的老架构的问题
RN的老架构任何业务逻辑需要JSB通信给JS线程做业务逻辑处理，再进行通信给shadow Thread，再通信给原生渲染出来，首屏、交互都有较大性能瓶颈

### 解决方案
让UI线程可解释执行渲染代码，可解释执行js基础逻辑，在UI线程尽量完成渲染交互闭环。

比如服务端数据请求，业务数据逻辑等无法在UI线程单独完成的数据逻辑才在JS线程运行执行，然后通过json序列化通信给UI线程。

### JSB实现方案

#### 注入式
安卓：通过addJavascriptInterface，传入bridge对象
低版本安卓存在漏洞
iOS通过javascriptCore

#### 拦截式
发送约定的协议的请求，客户端拦截到对应的请求后做对应的操作

- a标签需要用户操作
- location可能引起页面的跳转丢失调用
- 发送ajax请求安卓没有对应的拦截方法
一般使用iframe


# RN新老架构区别&优化点
## js层
- React：支持react16+新特性，包括async rendering、Data Fetching
- 增加js静态类型检查（codegen），来保证消息通信的安全，以解决javascript与native通信中被广为诟病的Bridge API 数据类型的问题
  - 减少数据类型错误
  - 减少数据验证的次数，提高通行性能
- 引入JSI（javascript interface），允许替换不同的JS引擎

## Bridge层
  - 划分成Fabic和TurboModules两部分，分别负责UI管理和js与native模块交互

## Fabric
  旧架构，需要通过JSB的JSON序列化信息进行复杂的跨线程交互，react - native - shadow Tree - Native UI
  新架构在c++层创建javascript与Native共享的 Shadow Tree，通过JSI将UI操作接口暴露给JavaScript，允许JavaScript直接控制高优先级任务，甚至允许同步调用
  应对列表快速滚动、页面切换、手势处理

## TurboModules
  实现native模块按需加载，减少启动时间，提高性能
    之前所有的native modules都要在应用启动时进行初始化，因为native不知道JavaScript将会调用
    哪些功能模块，而新的TurboModules允许**按需加载Native模块**，并在模块初始化之后直接持有其引用，不再依靠消息通信来调用功能模块，因此应用的启动时间也会有所提升
  
  通过TSI，可以让JS直接调用Native模块，实现同步操作
  



## Native层
  - 精简核心模块，将非核心模块拆分出去，作为社区模块，独立更新维护

## JSI
1、放弃桥的概念，转而使用javascript interface（JSI）的通信逻辑。JSI是一个接口，允许javascript持有c++的引用，允许c++持有javascript的引用。

这样c++可以直接调用javascript的对象，直接在javascript环境执行中执行一个方法

javascript也可以直接调用c++的对象，在c++环境中执行方法

#### 好处
- **同步执行**：现在可以同步执行原本需要同步执行的方法
- **并发**：可以在javascript上调用不同线程上执行的函数
- **更低的开销**：避免了数据序列化和反序列化的开销
- **代码共享**：通过引入c++，现在可以抽出与平台无关的代码，在平台直接共享
- **类型安全**：JSI可以通过flow或者typescript检查代码类型

## 重构

总结


#### 优化
1、针对双线程模型，做数据预处理，数据预置

2、针对线程间通信，做优化
 - 裁剪模版数据
  服务器返回的每个模版的数据比较大，而UI渲染并不需要完整数据，把每个模版上UI渲染上需要用到的数据放在state上，会同步到UI线程，把完整数据存放在this上，函数组件存放在useRef上

 - 对于双线程渲染，JS线程请求到的数据需要同步到UI线程进行渲染，用户刷列表比较长的化，数据量会比较大，此时新的一批数据如果同老的一批数据一起做更新（UI线程）会导致同步时间过长造成卡顿，将列表数据以id为state的key直接存放在state上，列表数据存放ID，列表渲染的时候从state上面以key取出数据，这样setState同步的数据就只有新增的数据。















