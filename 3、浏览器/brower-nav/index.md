# 输入url到页面展示

### 浏览器进程处理
处理请求链接，
搜索内容，使用默认搜索引擎，合成新的带搜索内容的URL
请求URL，拼接协议

发起请求前，触发beforeUnload事件

url发送给网络进程，浏览器进入等待状态


### 网络进程处理，请求，检查重定向
检查缓存

网络请求
解析DNS，获取ip地址，https会建立TLS连接
使用ip地址建立TCP连接，构建请求头请求行，把该域名相关的cookie加入到请求行中，发送请求

重定向
接收到响应头，网络进程解析，发现301、302，读取响应头里面的重定向地址，执行重定向

### 网络进程解析响应头，响应头提交浏览器进程，

解析content-type
网络进程解析到，如果是application/octet-stream类型，则交由下载器下载，表现为在页面内下载文件
如果是text/html，继续渲染流程，通知浏览器进程

### 浏览器进程，通知渲染进程
浏览器进程发送“提交导航”到渲染进程

### 渲染进程接收网络进程数据，
渲染进程，建立与网络进程的通道，接收html文件开始执行渲染流程，发送“确认提交”给浏览器进程，

### 浏览器进程移除旧文档，开始渲染新文档
浏览器进程收到后，开始移除旧文档，渲染新文档


# 渲染流程

### 解析文档构建dom树
渲染进程接收文档
遇到script标签会阻止渲染，下载，执行
遇到async，异步下载，同步执行，脚本间相互依赖，需要注意依赖关系，如果需要处理dom树，需要在dom构建完成后再执行
遇到defer，异步下载，延迟执行，按照script标签的顺序延迟执行

关于css，css资源会预解析出来，提前进行处理请求

### 构建cssom树
解析css样式
1. link引入的样式
2. style标签的样式
3. 内联的样式

##### 处理流程
1. 把样式表转换为浏览器能够理解的格式`document.styleSheets`
2. 转换样式表中的属性值，使其标准话`rem - px`
3. 计算出DOM树中每个节点的具体样式

可以理解为到这一步，完成构建cssom树

### 布局阶段
两棵树合成，计算布局信息，构建布局树。

### 分层
position、z-index、filer、opacity、overflow这些都会导致元素被提升为单独一层

### 图层绘制
根据分层信息，生成每一层的绘制列表

### 分块
合成线程，根据视口信息，把页面分块，把视口附近的图块优先生成位图，

### 删格化
通过删格化线程池来完成， 过程会使用GPU加速。

### 提交
把生成完成的图块提交给浏览器进程展示


## 整体流程
主线程
DOM - Style - layout - layers - Paint

构建DOM树，计算样式树，合成布局树，分层，计算绘制命令

合成线程
tiles - raster - draw quad

分块，光栅化，发送draw quad事件，表示绘制完成


重排：从DOM开始

重绘：从style开始

transform: translate(2px): 触发合成，非主线程，效率高


# 浏览器线程模型
四大进程
浏览器进程、渲染进程、GPU进程、网络进程


## 浏览器进程
主要负责界面显示、用户交互、子进程管理，同时提供存储等功能

## 渲染进程
核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在渲染进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

## GPU进程
Chrome刚开始发布的时候是没有GPU进程的，而GPU的使用初衷是为了实现3D CSS的效果，只是随后网友、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上引入了GPU进程

## 网络进程
主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最佳才独立出来成为一个单独的进程

插件进程

一个渲染流程大致如下

- 渲染进程将HTML内容转换为能够读懂的DOM树结构
- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式
- 创建布局树，并计算元素的布局信息
- 对布局树进行分层，并生成分层树
- 为每个图层生成绘制列表，并将其提交给合成线程
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
- 合成线程发送绘制图块命令DrawQuad给浏览器



DOM解析
style解析
计算布局，生成布局树
分层
生成绘制指令

分块
光栅化，光栅化线程池，GPU进程
提交给浏览器线程

重排会触发DOM树重构，布局树重构
重绘只需要重新生成绘制指令


## 浏览器事件循环
浏览器通过渲染进程处理js，渲染样式，

解析HTML、CSS
计算样式
处理图层绘制页面
执行js执行各种回调

渲染线程进入渲染流程会开启一个无限循环
每次循环取出消息队列一个任务执行，如果是异步任务，交由其他线程处理，如果没有进入休眠状态
当其他线程把异步任务处理完成，就会将后续的回调操作包装成新任务，加入消息队列末尾，等待渲染主线程拿到执行
其他所有进程的线程，都可以往消息队列末尾添加任务，当新任务添加时处于休眠状态，则会将其唤醒拿取任务执行

通过任务队列来调度任务
按照最新的标准至少有3个任务队列

微任务队列
交互队列
延迟队列

每次事件循环优先执行微任务队列，再执行宏任务队列


### 人工合成事件派发属于同步任务
即直接写在代码里的dom.click或dispatchEvent，相对于浏览器而言并不是真正的用户交互，会被当作同步任务执行。

只有用户触发的事件，才会作为异步任务，在事件循环中等待执行
```js
    // 写出下述程序的输出结果
    const btn = document.getElementById('button');
    function test() {
        console.log('function test!');
        Promise.resolve().then(() => {
            console.log('promise1');
        });
    }
    
    setTimeout(() => {
        console.log('set timer');
        Promise.resolve().then(test);
    }, 0);
    
    btn.onclick = () => {
        console.log('click button');
    };
    
    btn.click();
    
    Promise.resolve().then(() => {
        console.log('promise2');
    });
    
    console.log('script start');
    
    // 输出结果依次为：
    // click button
    // script start
    // promise2
    // set timer
    // function test!
    // promise1

```
