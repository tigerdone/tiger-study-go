时间：40min
一、基础概念（60分）

1. 什么是 JSX？在 React Native 中的作用是什么？ 
解答：
JSX是一种声明式语法，用于声明组件，可以通过babel编译成js代码，用于创建页面的元素。
在RN中的作用是声明组件。方便开发者声明式的创建组件

JSX是一种语法扩展，用于描述JavaScript中的UI结构。它看起来像HTML，但实际上是JavaScript语法的一个语法糖。JSX允许你在JavaScript代码中嵌入HTML元素的表示，并通过这些元素来构建UI。

JSX的基本特性：
- 声明式：JSX允许你声明UI结构，而不是逐步操作DOM
- 编译：JSX代码在最终运行时会被babel编译成React.createElement调用，因此它本质上仍然是JavaScript

## JSX在React Native中的作用

React Native使用JSX来构建和描述UI，就像React中一样。通过JSX，开发者可以声明地描述用户界面的结构和布局，使得编写React Native应用的代码更加简洁和易于理解。

### 1、UI组件声明
React Native使用JSX来创建原生组件。与React不同的是，React Native组件并不是HTML元素，而是原生视图组件（如View，Text，Image）JSX会将这些组件组合在一起形成一个UI树。

### JSX和原生组件的映射
在React Native中，JSX中的标签会被转译成相应的原生组件：
## JSX的优势
1、声明式编程
2、与JavaScript紧密结合
3、调试和维护性
4、跨平台开发

在React Native中，JSX允许开发者编写与平台无关的代码，React Native会将这些JSX转换成不同平台的原生组件。因此，开发者只需要编写一次UI代码，就可以运行在iOS和Android上




---
2.  解释 React Native 的组件生命周期方法。 
解答：
constractor，初始构造函数，用于创建组件的初始状态，包括state，对象属性
static getDerivedStateFromProps
render 渲染
componentDidMount，组件挂载完成

static getDerivedStateFromProps 根据上一次的props和state，计算一个对象，对象会被合并到下次渲染的state中
shouldComponentUpdate
render
getSnapShotBeforeUpdate 这个方法会在React将组件的render方法所生成的结果应用到文档之前运行，会返回一个对象，这个对象会被传递到 componentDidUpdate中使用
componentDidUpdate，组件更新完成，每次状态更新会执行

componentWillUnMount，组件将要卸载

componentDidCatch

---
3.  什么是虚拟 DOM？在 React Native 中如何工作？ 
解答：
虚拟dom是组件的状态抽象，是一种数据结构，通过数据结构来表示我们实际渲染的元素，方便算法进行调和，记录组件的状态、更新、结构、变化等
工作原理：
应用启动时，执行编译后的JSX代码，生成初始虚拟dom树，然后提交给shadow Thread进行布局计算，然后提交给native进行渲染
应用更新时，构建一颗workInProgress虚拟树，通过对比两颗树的差异，找出变化的更新，将更新记录到workIn Progress树上，然后将新树提交给shadow Thread进行布局计算，然后提交给native进行渲染

虚拟DOM是一种提高网页性能的技术，它通过在内存中维护一个与真实DOM相对应的虚拟表示，来避免直接操作浏览器的DOM，从而提升应用的渲染效率
在传统的网页开发中，当用户与页面交互时，JavaScript可能会直接修改DOM，这种操作往往是性能瓶颈，因为每次更新DOM都会导致浏览器重新计算页面的样式重新布局、重新绘制等，尤其是在复杂的应用中，频繁操作真实DOM会非常低效

虚拟DOM的工作原理如下：
1、创建虚拟DOM树：每次组件的状态变化时，React会首先更新一个虚拟DOM，计算出新的UI状态
2、与旧的虚拟DOM进行对比
3、最小化更新


---
4. 什么是高阶组件（HOC）？在 React Native 中如何使用？ 
解答：
高阶组件是复用逻辑的一种方案。
把需要复用的逻辑放到组件内，然后render传入的子组件，达到复用逻辑的效果

高阶组件是一种设计模式，在React中被用来复用组件逻辑。
简单来说，高阶组件是一个函数，他接受一个组件作为参数，并返回一个新的组件。通过这种方式，HOC可以为传入的组件增强或修改行为，而不直接修改组件的内部实现

HOC的核心思想是组件之间共享逻辑而不是继承

HOC的特点：
1、接收组件作为参数：高阶组件总是接受一个组件作为参数
2、返回一个新的组件：高阶组件返回的是一个增强版的组件，而不是修改原始组件
3、不修改原始组件，HOC的一个重要特点是它不直接修改传入的组件，而是通过封装的方式增强它
3、复用逻辑：HOC允许多个组件共享相同的逻辑，而不需要复制代码

### 高阶组件定义
高阶组件是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会在原组件的基础上添加一些额外的功能，如状态管理、数据获取、权限验证等。可以把高阶组件看作一个组件工厂，用于生产增强版的组件

### 高阶组件的用途
代码复用

功能增强

状态管理和数据获取
```jsx
import React from 'react';
function withClassName(){
    return function EnhancedComponent(props) {
        const { className, ...rest } = props;
        return <Component className="enhanced - component" {...rest}>
    }
}

```



---

5. 什么是fiber，fiber解决了什么问题？另外简述Fiber更新机制
解答：
fiber是调和方案的数据结构，JSX编译成的代码通过createElement创建fiber，然后通过嵌套结构调用生成fiber树
主要为了实现时间切片方案，实现了任务暂停，然后交还控制权给运行时处理高优先级任务。
触发更新时，会创建workInprogress树，通过对比与current树的差异，找到需要更新的内容，将更新内容挂到fiber树上，然后在commit阶段将内容更新到页面上

---

6. Redux的中间件原理是什么？ 介绍一些熟悉的中间件。
解答：


---
7. 在 React Native 中，如何优化列表组件的性能？ 
解答：
如果是长列表，请求新一刷数据返回时，如果重新设置整个列表，会把整个列表数据JSON序列化到渲染线程进行渲染，数据量大会造成卡顿
可以将列表元素通过id为key设置在state上，然后数组列表只保存id，新一刷数据同时设置id列表、id对应的新数据到state上，实现增量更新。可以解决数据量大卡顿问题



---
8. 如何在 Next.js 应用程序中实现服务器端缓存？
解答：
通过redius，将需要缓存的数据设置一个key到redius列表中


---
9. 如何优化 Next.js 应用程序的性能？Next.js 有哪些常用的性能优化手段？
解答：


---
10. 为什么使用tailwindcss? 优势在哪里？
解答：


---
11. http强缓存和协商缓存的区别？常用字段有哪些？使用场景是什么？
解答：
强缓存不需要服务端，通过判断缓存字段直接使用，协商缓存需要根据新鲜度询问服务器是否使用缓存
常用字段：
强缓存
cache-contral
expries

协商缓存
last-modify
if-modify-since

Etag
if-none-match
协商缓存常用于应用入口文件html、js文件、css文件，通过添加etag，判断文档内容有没有变化，有更新能及时更新到。

强缓存常用于静态资源，如图片、视频



---
12. 什么是路由懒加载？原理是什么？
解答：
路由懒加载是用户访问到对应路由再加载对应路由的资源，从而减少主要内容的资源大小，提升性能

原理监听路由跳转，跳转到指定的页面时再通过import动态加载对应的资源，打包后把加载的内容拆包到单独的文件


---
13. 说一下对node循环机制的理解？
解答：
一个node循环有6大阶段，每个阶段处理不同的任务，定时器，宏任务、微任务等
处理完一个宏任务，再将微任务队列处理完成，再执行下一个宏任务


---
14. 介绍下浏览器渲染的过程？
解答：
浏览器加载html页面，流式解析，遇到js会下载js并执行js再继续解析，遇到css会阻塞渲染

解析html结构生成dom树，解析css树生成cssom树，两颗树合并成渲染树，分层、分块、删格化，渲染


---
15. 如何解决跨域？
解答：
JSONP
CORS方案
postMessage方案
代理方案


二、代码题（40分）
16. 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [start(i), end(i)] 
请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
 
示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

解答：
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    let res = [];
    let currentFlag = intervals[0];

    for(let i = 1; i < intervals.length ;i++){
        let [left, right] = currentFlag;
        while ( i < intervals.length ) {
            let [newLeft, newRight] = intervals[i]
            if (right >= newLeft) {
                right = newRight;
                i++;
                if (i === intervals.length ) {
                    res.push([left, right]);
                }
            } else {
                res.push([left, right]);
                currentFlag = intervals[i];
                break;
            }
        }
    }
    return res;
};

function customPromiseAll(iterable) {
  // todo
  let index = 0
  
  return new Promise((resolve, reject) => {
        let resList = []
        iterable.foreach((item,index) => {
            item.then((res) => {
                resList[index] = res;
                index++;
                if (index === iterable.length) {
                    resolve(resList)
                }
            }).catch(err => {
                reject(err)
            })
        })
  })
 
}

// 示例用法：
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

customPromiseAll([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // 输出 [1, 2, 3]
  })
  .catch((error) => {
    console.error(error);
  });




