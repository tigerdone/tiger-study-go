# 为什么选vite

## 现实问题

在浏览器支持ES模块之前，JavaScript并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对“打包”这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。

时过境迁，我们见证了诸如webpack、rollup和Parcel等工具等变迁，它们极大地改善了前端开发者的开发体验。

然而，当我们构建越来越大型的应用时，需要处理的JavaScript代码量也撑指数级增长。包含数千个模块的大型项目相当普遍，基于JavaScript开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至几分钟）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感

vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持ES模块，且越来越多的JavaScript工具使用编译型语言编写

## 缓慢 的服务器启动

当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。

Vite 通过在一开始将应用中的模块区分为依赖和源码两类，改进了开发服务器的启动时间。

- **依赖** 大多=为在开发时不会变动的纯JavaScript，一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如ESM或者Commonjs）

Vite将会使用esbuild预构建依赖。esbuild使用Go编写，并且比以JavaScript编写的打包器预构建依赖快10-100倍

- **源码** 通常包含一些并非直接是javascript的文件，需要转换（例如JSX、CSS或者Vue/Svelte组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）

Vite以原生ESM方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：vite只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。

## 缓慢的更新
基于打包启动时，当源文件被修改后，重新构建整个包是低效的，原因显而易见：更新速度会随着应用体积的增加而线性下降。

一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍然需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块替换（HMR）：允许一个模块“热替换”它自己，而不会影响页面其余部分，这大大改进了开发体验 --- 然而，在实践中我们发现，即使采用了HMR模式，其热更新速度也会随着应用规模的增长而显著下降。

在Vite中，HMR是在原生ESM上执行的，当编辑一个文件时，Vite只需要精确地使已编辑的模块与其最近的HMR边界之间的链失活，（大多数时候只是模块本身），使得无论应用大小如何，HMR始终能保持快速更新。

Vite同时利用HTTP头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据304  Not Modified 进行协商缓存，而依赖模块请求则会通过**Cache-Control： max-age=31536000,immutable**进行强缓存，因此一旦被缓存它们将不再需要被请求

一旦你体验到Vite的神速，你---

## 依赖预构建
当你首次启动Vite时，Vite在本地加载你的站点之前预构建了项目依赖。默认情况下，它是自动切透明地完成的。

#### 原因
这就是Vite执行时所做的“依赖预构建”。这个过程有两个目的：
1、CommonJS和UMD兼容性：在开发阶段中，Vite的开发服务器将所有代码视为原生ES模块。因此Vite必须先将CommonJS或UMD形式提供的依赖项转换为ES模块。

在转换CommonJS依赖项时，Vite会进行智能导入分析，这样即使模块的导出是动态分配的（例如react），具名导入（named import）也能正常工作：

```js
// 符合预期
import React, { uesState } from 'react';
```


2、性能：为了提高后续页面的加载性能，vite将哪些具有许多内部模块的ESM依赖项转换为单个模块。

有些包将它们的ES模块构建为许多单独的文件，彼此导入，例如。lodash-es有超过600个内置模块，当我们执行import { debounce } from 'lodash-es'时，浏览器同时发出600个https请求，即使服务器能够轻松处理他们，但大量的请求会导致浏览器网络拥塞，使页面加载变得明显缓慢

通过将lodash-es预构建成单个模块，现在我们只需要一个HTTP请求




## 为什么生产环境

尽管原生ESM现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的ESM仍然效率低下，（即使使用HTTP/2）。为了在生产环境中获得最佳的加载性能，最好是将代码进行tree-shaking、懒加载和chunk分割（已获得更好的缓存）。

要确保开发服务器和生产环境构建之间的最优输出和行为一致并不容易。所以Vite附带了一套构建优化和构建命令，开箱即用

## 为何不使用ESBuild打包
虽然Vite利用esbuild在开发环境中预打包一些依赖，但vite不会在生产构建中使用esbuild作为打包工具。

Vite目前的插件API与使用esbuild

